# slam-path_planning

* ROS2 관련 문서 : https://docs.ros.org/en/foxy/index.html

알아봐야할 것 : 
1. ROS 외부 네트워크로 Deepracer랑 연결하기 (IP 주소를 이용해 연결)
2. Deepracer의 토픽들이 각각 어떤 토픽들인지
3. ROS에서 receive로 데이터를 지속적으로 받을 수 있는지 아니면 일회성인지 ( 만약 일회성이면 loop문 안에 receive를 사용해야 할듯 )
4. 반복문에 사용되는 Scan횟수는 어떻게 지정해야 하는지 (즉, SLAM의 종료 시점 또는 조건은 어떻게 결정해야 하는지)
5. Deepracer 컨트롤에 대해서는 진전이 있는지
 

[ROS 용어 정리](https://neosla.tistory.com/36?category=825336)  
[ROS 2로 시작하는 로봇 프로그래밍](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=276616576)

#### 2개의 라이다 센서 데이터를 이용해서 현재 위치 추정
[Pose Estimation 방법1] (https://kr.mathworks.com/help/nav/ref/matchscans.html)

[Pose Estimation 방법2] (https://kr.mathworks.com/help/nav/ref/matchscansline.html)

[Pose Estimation 방법3] (https://kr.mathworks.com/help/nav/ref/matchscansgrid.html)

[Estimate Robot Pose with Scan Matching](https://www.mathworks.com/help/nav/ug/estimate-robot-pose-with-scan-matching.html)

---


### 진행예정과정 : 
#### 1. 라이다를 통해 얻은 laser scan 데이터를 이용해 SLAM으로 지도를 작성
#### 2. 작성한 그림을 mat파일로 변환한 후 경로탐색 스크립트에서 SLAM을 통해 작성한 지도에 해당하는 mat 파일을 이용해서 경로탐색 시작
#### 3. 알고리즘을 통해 계산된 경로를 따라서 Deepracer 이동
---


#### 노드 : ROS에서 실행되는 최소 단위의 프로세서, 즉 하나의 실행 가능한 프로그램이라 생각
ROS에서는 하나의 목적에 하나의 노드를 작성하길 권하며, 재사용이 쉽게 구성하여 개발하기를 권한다.

Ex) 모바일 로봇의 경우, 로봇을 구동하기 위하여 각 프로그램을 세분화시킨다. 즉 센서 드라이브, 센서 데이터를 이용한 변환, 장애물 판단, 모터 구동, 엔코더 입력, 내비게이션 등 세분화된 작은 노드들을 이용한다.

노드는 구동과 함께 마스터에 노드와 퍼블리셔, 서브스크라이버, 서비스 서버, 서비스 클라이언트의 역할을 하는 노드, 토픽, 서비스의 각 이름, 메시지형태, URI 주소와 포트를 등록한다. 이 정보들을 기반으로 각 노드는 노드끼리 토픽과 서비스를 이용하여 메시지를 주고 받을 수 있다.

---

#### 메시지 : 노드는 메시지를 통해 노드 간의 데이터를 주고 받는다. 메시지는 integer, floating point, boolean같은 변수 형태이다. 메시지 안에 메시지를 품고 있는 간단한 데이터 구조나 메시지들이 나열된 배열과 같은 구조도 사용할 수 있다.

각각의 메시지는 메시지 타입을 가지고 있음.
모든 메시지 타입 이름은 패지키 이름과 '/' 그리고 타입 이름으로 구성

---

#### 토픽 : 이야깃거리. 퍼블리셔 노드가 하나의 이야깃거리에 대해서 토픽으로 마스터에 등록한 후, 이야깃거리에 대한 이야기를 메시지 형태로 퍼블리시한다. 이 이야깃거리를 수신받기 원하는 서브스크라이버 노드는 마스터에 등록된 토픽의 이름에 해당하는 퍼블리셔 노드의 정보를 받는다. 이 정보를 기반으로 서브스크라이버 노드는 퍼블리셔 노드와 직접 연결하여 메시지를 토픽으로 송수신하게 된다.

---

#### 퍼블리시 및 퍼블리셔 : 퍼블리시는 토픽의 내용에 해당하는 메시지 형태의 데이터를 송신하는 것을 의미. 퍼블리셔 노드는 퍼블리시를 수행하기 위해서 토픽을 포함한 자신의 정보들을 마스터에 등록하여 서브스크라이브를 원하는 서브스크라이버 노드에 메시지를 보낸다. 퍼블리셔는 이를 실행하는 개체로써 노드에서 선언한다. 퍼블리셔는 하나의 노드에서 복수로 선언할 수 있다.

#### 서브스크라이브 및 서브스크라이버 : 토픽의 내용에 해당하는 메시지 형태의 데이터를 수신하는 것을 의미. 서브스크라이버 노드는 서브스크라이브를 수행하기 위해서 토픽을 포함한 자신의 정보들을 마스터에 등록하고, 구독하고자 하는 토픽을 퍼블리시하는 퍼블리셔 노드의 정보를 마스터로부터 받는다. 서브스크라이버는 이를 실행하는 개체로서 노드에서 선언한다. 서브스크라이버는 하나의 노드에서 복수로 선언할 수 있다.

퍼블리시와 서브스크라이브 개념의 토픽 전송 방식은 비동기 방식이라 필요에 따라서 주어진 데이터를 전송하고 받기에 매우 훌륭한 방법. 또한 한번의 접속으로 지속적인 메시지를 송수신하기 때문에 지속해서 메시지를 발송해야 하는 센서 데이터에 적합하여 많이 사용하고 있다. 하지만 때에 따라서는 요청과 응답이 함께 사용되는 동기방식의 메시지 교환 방식도 필요하다. 이에 따라, ROS에서는 서비스라는 이름으로 메시지 동기방식을 지원한다. 서비스는 요청이 있을 때, 응답하는 서비스 서버와 요청하고 응답받는 서비스 클라이언트로 나뉜다. 서비스는 토픽과는 달리 일회성 메시지 통신이다. 서비스의 요청과 응답이 완료되면 두 노드의 접속은 끊긴다.


